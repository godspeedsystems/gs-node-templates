summary: Fetch User
tasks:
  - id: lending_service_db_user_one
    fn: datasource.lending_service_db.User.findUnique
    args:
      where:
        id: <% parseInt(inputs.params.id) %>
    logs:
      before:
        message: About to get user from id
        level: debug
        attributes:
          fn_event_type: find_one
          fn_entity_type: User
          fn_entity_id: <%inputs.params.id%>
      after:
        message: Find one reponse for User in task
        level: debug
        attributes:
          fn_event_type: find_one
          fn_entity_type: User
          fn_entity_id: <%inputs.params.id%>
        params:
          response: <%outputs.lending_service_db_user_one.data%>
    caching:
      # datasource: in_mem_cache #the name of the datasource instance to use instead of default cache
      key: <%'User_' + inputs.params.id%> # <Optional. Key name which is used to read from and write cache result of this task in applicable cache. Also see noRead and noWrite flags>
      #invalidate: # <Key name which we want to delete/remove from cache e.g. this feature can be used in CRUD types task. While delete operation, invalidate the cache of read or update task>
      cache_on_failure: false # <true|false, whether you want to cache the failure result or not. By default, it is false>
      #options: #Optional
      #  EX: 200 # <timer in seconds, until the cached result is valid> #Can pass any of RedisOptions, if supported by the specific caching Datasource 
      # noRead: true # <true|false. Default false. a flag to specify to not to look into cache and executing task's function nonetheless. But the response from the task is set in the key specified (unless noWrite is set to true). Set noRead to true if you don't want to use cache for this task, but want to store this tasks response as a key for accessing this task's result somewhere else>
